#!/usr/bin/env python3
"""
Contact Form Monitor using Selenium to bypass WAF protection
Requires: pip install selenium
Also need to download ChromeDriver from https://chromedriver.chromium.org/
Working script for its use case.
"""

from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import json
import time
import os
import requests
from datetime import datetime
from items import EMAIL, PASSWORD, API_KEY, API_URL, DISCORD_WEBHOOK

# Configuration
CONFIG = {
    'API_URL': API_URL,
    'LAST_COUNT_FILE': 'last_message_count.txt',
    'CHECK_INTERVAL': 900,  # 15 minutes
    
    # Email notification
    'SMTP_SERVER': 'smtp.gmail.com',
    'SMTP_PORT': 587,
    'EMAIL_USER': EMAIL,
    'EMAIL_PASS': PASSWORD,
    'NOTIFY_EMAIL': EMAIL,
    
    # API key
    'API_KEY': API_KEY,
    
    # Discord Webhook
    'DISCORD_WEBHOOK': DISCORD_WEBHOOK
}

def setup_driver():
    """Set up Chrome driver with options"""
    chrome_options = Options()
    chrome_options.add_argument('--headless')  # Run in background
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.add_argument('--disable-gpu')
    chrome_options.add_argument('--window-size=1920,1080')
    chrome_options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
    
    try:
        driver = webdriver.Chrome(options=chrome_options)
        return driver
    except Exception as e:
        print(f"Error setting up Chrome driver: {e}")
        print("Make sure ChromeDriver is installed and in your PATH")
        return None

def get_current_messages():
    """Fetch messages using Selenium to bypass WAF"""
    driver = setup_driver()
    if not driver:
        return None
    
    try:
        url = f"{CONFIG['API_URL']}?api_key={CONFIG['API_KEY']}"
        print(f"Loading URL with Selenium: {url}")
        
        driver.get(url)
        
        # Wait for JavaScript to execute and page to load
        time.sleep(5)
        
        # Wait for either JSON content or error message
        try:
            # Check if we got JSON response
            page_text = driver.page_source
            
            # Look for JSON in the page
            if page_text.startswith('{"') or '{"success"' in page_text:
                # Extract JSON from page source
                start_idx = page_text.find('{"')
                if start_idx != -1:
                    json_text = page_text[start_idx:]
                    # Find end of JSON
                    brace_count = 0
                    end_idx = 0
                    for i, char in enumerate(json_text):
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                end_idx = i + 1
                                break
                    
                    if end_idx > 0:
                        json_text = json_text[:end_idx]
                        data = json.loads(json_text)
                        
                        if data.get('success'):
                            messages = data.get('messages', [])
                            print(f"Successfully fetched {len(messages)} messages")
                            return messages
                        else:
                            print(f"API error: {data.get('error', 'Unknown')}")
                            return None
            
            # If no JSON found, check for error messages
            if 'requires Javascript' in page_text:
                print("Still blocked by JavaScript challenge")
                return None
            elif 'Unauthorized' in page_text:
                print("API key authentication failed")
                return None
            else:
                print("Unexpected page content:")
                print(page_text[:500])
                return None
                
        except json.JSONDecodeError as e:
            print(f"JSON parsing failed: {e}")
            print(f"Page content: {driver.page_source[:500]}")
            return None
    
    except Exception as e:
        print(f"Selenium error: {e}")
        return None
    finally:
        driver.quit()

def get_last_message_count():
    """Get last known count"""
    try:
        with open(CONFIG['LAST_COUNT_FILE'], 'r') as f:
            return int(f.read().strip())
    except:
        return 0

def save_message_count(count):
    """Save current count"""
    try:
        with open(CONFIG['LAST_COUNT_FILE'], 'w') as f:
            f.write(str(count))
    except Exception as e:
        print(f"Error saving count: {e}")

def send_discord_notification(new_messages):
    """Send notification via Discord webhook"""
    # try:
    for msg in new_messages:
        data = {
            "content": "ðŸ”” New contact form message!",
            "embeds": [{
                "title": "New Contact Message",
                "color": 0x00ff00,
                "fields": [
                    {"name": "Name", "value": msg.get('name', 'Unknown'), "inline": True},
                    {"name": "Email", "value": msg.get('email', 'Unknown'), "inline": True},
                    {"name": "Message", "value": msg.get('message', '')[:200] + "...", "inline": False},
                    {"name": "Time", "value": msg.get('timestamp', 'Unknown'), "inline": True}
                ]
            }]
        }
        response = requests.post(CONFIG['DISCORD_WEBHOOK'], json=data, timeout=10)
        return response.status_code == 204
    # except Exception as e:
    #     print(f"Discord notification failed: {e}")
    #     return False

def send_email_notification(new_messages):
    """Send email notification"""
    # try:
    import smtplib
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    
    server = smtplib.SMTP(CONFIG['SMTP_SERVER'], CONFIG['SMTP_PORT'])
    server.starttls()
    server.login(CONFIG['EMAIL_USER'], CONFIG['EMAIL_PASS'])
    
    for msg in new_messages:
        email_msg = MIMEMultipart()
        email_msg['From'] = CONFIG['EMAIL_USER']
        email_msg['To'] = CONFIG['NOTIFY_EMAIL']
        email_msg['Subject'] = f"RESUME WEBSITE: New Contact Message from {msg.get('name', 'Unknown')}"
        
        body = f"""
New contact form message:

Name: {msg.get('name', 'Unknown')}
Email: {msg.get('email', 'Unknown')}
Time: {msg.get('timestamp', 'Unknown')}

Message:
{msg.get('message', '')}

View admin panel: https://jpm.social-networking.me/admin.php
        """
        
        email_msg.attach(MIMEText(body, 'plain'))
        server.send_message(email_msg)
    
    server.quit()
    return True
    # except Exception as e:
        # print(f"Email failed: {e}")
        # return False

def check_for_new_messages():
    """Main check function"""
    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Checking messages...")
    
    current_messages = get_current_messages()
    if current_messages is None:
        return False
    
    current_count = len(current_messages)
    last_count = get_last_message_count()
    
    print(f"Current: {current_count}, Last: {last_count}")
    
    if current_count > last_count:
        new_count = current_count - last_count
        new_messages = current_messages[-new_count:]
        
        if send_email_notification(new_messages):
            print(f"Sent notifications for {new_count} new messages")
            save_message_count(current_count)
        else:
            return False
        
        if send_discord_notification(new_messages):
            print(f"Sent Discord notifications for {new_count} new messages")
        else:
            return False
    else:
        print("No new messages")
        save_message_count(current_count)
    
    return True

if __name__ == "__main__":
    print("Contact Monitor (Selenium) starting...")
    check_for_new_messages()